{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"src/knldef.rs","byte_start":4905,"byte_end":7083,"line_start":213,"line_end":247,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_tcb_queue() {","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut tcb_ready = TCB { context: core::ptr::null_mut(), pre: core::ptr::null_mut(), next: core::ptr::null_mut(), state: TSTAT::TsReady, tskadr: 0, itskpri: 0, stkadr: 0, stksz: 0, wupcnt: 0, waifct: TWFCT::TwfctNon, waitim: 0, waierr: KernelError::OK, waiptn: 0, wfmode: 0, p_flgptn: 0, waisem: 0 }; ","highlight_start":1,"highlight_end":307},{"text":"    let mut tcb_wait = TCB { context: core::ptr::null_mut(), pre: core::ptr::null_mut(), next: core::ptr::null_mut(), state: TSTAT::TsWait, tskadr: 0, itskpri: 0, stkadr: 0, stksz: 0, wupcnt: 0, waifct: TWFCT::TwfctNon, waitim: 0, waierr: KernelError::OK, waiptn: 0, wfmode: 0, p_flgptn: 0, waisem: 0 }; ","highlight_start":1,"highlight_end":305},{"text":"    let mut tcb_dormant = TCB { context: core::ptr::null_mut(), pre: core::ptr::null_mut(), next: core::ptr::null_mut(), state: TSTAT::TsDormant, tskadr: 0, itskpri: 0, stkadr: 0, stksz: 0, wupcnt: 0, waifct: TWFCT::TwfctNon, waitim: 0, waierr: KernelError::OK, waiptn: 0, wfmode: 0, p_flgptn: 0, waisem: 0 }; ","highlight_start":1,"highlight_end":311},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut q = TcbQueue { head: core::ptr::null_mut() };","highlight_start":1,"highlight_end":58},{"text":"    let p_tcb_ready:   *mut TCB = core::ptr::addr_of_mut!(tcb_ready);","highlight_start":1,"highlight_end":70},{"text":"    let p_tcb_wait:    *mut TCB = core::ptr::addr_of_mut!(tcb_wait);","highlight_start":1,"highlight_end":69},{"text":"    let p_tcb_dormant: *mut TCB = core::ptr::addr_of_mut!(tcb_dormant);","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    q.add_entry(p_tcb_ready);","highlight_start":1,"highlight_end":30},{"text":"    q.add_entry(p_tcb_wait);","highlight_start":1,"highlight_end":29},{"text":"    q.add_entry(p_tcb_dormant);","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    assert_eq!(tcb_ready.state, (*q.head).state);","highlight_start":1,"highlight_end":50},{"text":"    assert_eq!(tcb_wait.state,  (*(*q.head).next).state); ","highlight_start":1,"highlight_end":59},{"text":"    assert_eq!(tcb_dormant.state, (*(*(*q.head).next).next).state);","highlight_start":1,"highlight_end":68},{"text":"    assert_eq!(true,(*(*(*q.head).next).next).next == core::ptr::null_mut()); ","highlight_start":1,"highlight_end":79},{"text":"    assert_eq!((*(*q.head).pre).state, (*(*(*q.head).next).next).state);","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    q.remove_top();","highlight_start":1,"highlight_end":20},{"text":"    assert_eq!(tcb_wait.state, (*q.head).state);","highlight_start":1,"highlight_end":49},{"text":"    assert_eq!(tcb_dormant.state, (*(*q.head).next).state);","highlight_start":1,"highlight_end":60},{"text":"    assert_eq!(true,(*(*q.head).next).next == core::ptr::null_mut());","highlight_start":1,"highlight_end":70},{"text":"    assert_eq!(tcb_dormant.state, (*(*q.head).pre).state);","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    q.remove_entry(p_tcb_dormant);","highlight_start":1,"highlight_end":35},{"text":"    assert_eq!(tcb_wait.state, (*q.head).state);","highlight_start":1,"highlight_end":49},{"text":"    assert_eq!(true, (*q.head).next == core::ptr::null_mut());","highlight_start":1,"highlight_end":63},{"text":"    assert_eq!(tcb_wait.state, (*(*q.head).pre).state);","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    q.remove_top();","highlight_start":1,"highlight_end":20},{"text":"    assert_eq!(true, q.head == core::ptr::null_mut());","highlight_start":1,"highlight_end":55},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/knldef.rs","byte_start":4897,"byte_end":4904,"line_start":212,"line_end":212,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"/rustc/b6a8c762eed0ae0383658c38d65cb91bbd9800a1/library/core/src/macros/mod.rs","byte_start":55965,"byte_end":55979,"line_start":1601,"line_end":1601,"column_start":5,"column_end":19,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0463]\u001b[0m\u001b[0m\u001b[1m: can't find crate for `test`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/knldef.rs:213:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m#[test]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this procedural macro expansion\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mfn test_tcb_queue() {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m214\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m215\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut tcb_ready = TCB { context: core::ptr::null_mut(), pre: core::ptr::null_mut(), next: core::ptr::null_mut(), state: TSTA\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut tcb_wait = TCB { context: core::ptr::null_mut(), pre: core::ptr::null_mut(), next: core::ptr::null_mut(), state: TSTAT\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    assert_eq!(true, q.head == core::ptr::null_mut());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m247\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcan't find crate\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0463]\u001b[0m\u001b[0m\u001b[1m: can't find crate for `test`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 2 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}
